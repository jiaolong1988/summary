java的锁时对管程模型的实现和补充。
1. synchronized 隐士锁，内部只对一个变量同步。
2. ReentrantLock重入锁，对隐士锁的补充，可重复获取同一把锁。为了防止死锁，在获取锁的时候，支持超时、能够根据响应中断获取锁的动作、获取锁失败直接返回。
				重入锁的Condition，支持多变量的同步。
3.ReentrantReadWriteLock重入读写锁，针对读多写少的场景设计的锁，当运行写锁的时候，所有使用读锁的线程进入阻塞状态，
						当写锁执行完毕后，读锁可正常工作读取数据。不支持锁升级，仅支持降级。
4.StampedLock 的功能仅仅是 ReentrantReadWriteLock 的子集,不支持重入，比	ReentrantReadWriteLock更快。不仅StampedLock实现了多个读不互相阻塞，同时在读操作时不会阻塞写操作。
也就是锁升级去修改数据
			
同步						
1. Semaphore信号量，值为1可以当锁，当大于1时，可使用允许多个线程同时执行任务。相当于限流器。
2.CountDownLatch 主要用来解决一个线程等待多个线程的场景，可以类比旅游团团长要等待所有的游客到齐才能去下一个景点；
3.CyclicBarrier 是一组线程之间互相等待，更像是几个驴友之间不离不弃。
区别
1. CountDownLatch的计数器是不能循环利用，也就是说一旦计数器减到 0，再有线程调用 await()，该线程会直接通过。
2. CyclicBarrier 的计数器是可以循环利用的，而且具备自动重置的功能，一旦计数器减到 0 会自动重置到你设置的初始值。
3. CyclicBarrier 还可以设置回调函数，可以说是功能丰富。
