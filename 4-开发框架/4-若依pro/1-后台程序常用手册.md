



# SpringBoot

## 1.启动扫描

```java
@SpringBootApplication(scanBasePackages = {"${yudao.info.base-package}.server",  
                                           "${yudao.info.base-package}.module"} )
```

- ${yudao.info.base-package} 是占位符，具体信息在 `application.yaml`中配置
> ![image-20250806151758084](assets/image-20250806151758084.png)



## 2.ApplicationRunner

- 在 Spring Boot 中，`ApplicationRunner` 接口是一个用于在应用启动后执行特定逻辑的接口。它属于 Spring Framework 的一部分，主要用于在应用上下文加载完成后、应用启动过程中执行一些初始化操作或业务逻辑。

![image-20250806171949059](assets/image-20250806171949059.png)





## 3.banner.txt

- 在 Spring Boot 应用中，banner.txt 是一个用于`自定义`**应用启动时显示的欢迎信息（即 Banner）的文件**。Spring Boot 启动时**会自动加载并显示这个文件的内容**，通常用于展示项目名称、版本号、版权信息等。

- 位置 

  > src/main/resources/banner.txt

![image-20250806174153802](assets/image-20250806174153802.png)

## 4.springBootTest

- @RunWith(SpringRunner.class)	 // <1.1>

  > @RunWith 注解，是 JUnit 所提供。
  >
  > 通过添加 @RunWith(SpringRunner.class)，告诉 JUnit 使用 SpringRunner 作为 Junit Runner，从而在测试的时候，可以创建 Spring 容器。

- @SpringBootTest(**classes = Application.class**)               

  > - `@SpringBootTest` 是 **Spring Boot Test** 模块提供的一个注解，用于启动完整的 Spring 应用上下文（ApplicationContext），以便进行集成测试。
  >
  > - classes = Application.class
  >   - **作用：指定测试时只加载 Application.class 所定义的配置，而不是自动扫描整个项目。**
  >   - 优点：
  >     1. 提高测试速度（减少不必要的 Bean 加载）。
  >     2. 避免因其他配置导致的冲突或错误。

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
public class UserMapperTest {

    @Autowired
    private UserMapper userMapper;

    @Test
    public void testInsert() {
        UserDO user = new UserDO().setUsername(UUID.randomUUID().toString())
                .setPassword("nicai").setCreateTime(new Date())
                .setDeleted(0); 
        userMapper.insert(user);
    }
}

```

## 5.使用外部配置文件启动

```bash
java -jar  yudao-server.jar -Xms512m -Xmx512m --spring.config.location=/root/yudao-server/config/ --spring.profiles.active=dev
```



## 6.全局拦截/异常/统一前缀

- [参考文章](https://www.iocoder.cn/Spring-Boot/SpringMVC/)

```java
// 统一前缀
cn.iocoder.yudao.framework.web.config.YudaoWebAutoConfiguration
// 统一返回结果
cn.iocoder.yudao.framework.web.core.handler.GlobalResponseBodyHandler
//统一异常    
cn.iocoder.yudao.framework.web.core.handler.GlobalExceptionHandler
```

## 7.拦截器的原理

![image-20250912152442369](assets/image-20250912152442369.png)



# 注解

## spring

### 1.ConditionalOnProperty

> 是spring boot注解，根据 **配置文件中的属性值** 来决定是否加载某个 Bean 或配置类。

```java
cn.iocoder.yudao.framework.apilog.config.YudaoApiLogAutoConfiguration
  
//案例    
@ConditionalOnProperty(prefix = "yudao.access-log", value = "enable", matchIfMissing = true)
public FilterRegistrationBean<ApiAccessLogFilter> apiAccessLogFilter(){
    
}    

//参数解释
prefix = "yudao.access-log"
// 表示配置项的前缀。Spring Boot 会从配置文件（如 application.yml 或 application.properties）中查找以 yudao.access-log 开头的属性。

value = "enable"
// 表示要检查的属性名是 yudao.access-log.enable。

matchIfMissing = true
// 如果配置文件中没有设置 yudao.access-log.enable 这个属性，那么也认为条件成立（即默认为 true）。
```

### 2.RestControllerAdvice

> `@RestControllerAdvice` 是 Spring 框架中一个非常重要的注解，主要用于**全局异常处理和统一响应封装**。该注解是一个bean.



### 3.PostConstruct

> `@PostConstruct` 是 Java 中用于标注方法的注解，属于 **JSR-250** 标准的一部分（即 Java 的标准注解之一），主要用于在 **Spring 容器初始化 Bean 时**，在 Bean 的依赖注入完成后，**自动调用该方法**。

```java
@Component
public class MyService {
    
    @PostConstruct
    public void init() {
        System.out.println("Bean 初始化完成，执行初始化逻辑...");
        // 可以在这里进行一些初始化操作
    }
}
```

### 4.@Transactional

> `@Transactional(rollbackFor = Exception.class)` 是 Spring 框架中用于声明事务管理的注解，它表示该方法在发生异常时会触发事务回滚。



## Constraint

> 自定义注解时，使用到的一个注解

@Constraint(validatedBy = MobileValidator.class)：指定校验器类

- @Constraint 是 Bean Validation 框架中的一个注解，用于声明这是一个校验注解。
- validatedBy = MobileValidator.class 表示该注解的校验逻辑由 MobileValidator 类来实现。

```java
@Constraint(
        validatedBy = MobileValidator.class
)
public @interface Mobile {
    ...
}
```



## Lombok

### 1.@RequiredArgsConstructor

> 是Lombok 注解，根据类中所有 `final` 字段或带有 `@NonNull` 注解的字段，自动生成一个包含这些字段的构造函数。

```java
@RequiredArgsConstructor
public class WebSocketAuthorizeRequestsCustomizer {
	private final WebSocketProperties webSocketProperties;
}

//调用
new WebSocketAuthorizeRequestsCustomizer(webSocketProperties);
```

### 2.@Data

> `@Data` 是 **Lombok** 库中的一个注解，用于简化 Java 类的代码编写。它是一个 **组合注解**，相当于同时添加了以下多个注解的功能：
>
> - `@ToString`
> - `@EqualsAndHashCode`
> - `@Getter`
> - `@Setter`
> - `@RequiredArgsConstructor`
>
> `@EqualsAndHashCode(callSuper = true)` 是 **Lombok** 提供的一个注解，用于在生成 `equals()` 和 `hashCode()` 方法时，**包含父类的字段**。默认是false;



# Mybatis

## @Param

- 主要用于 **在 Mapper 接口中传递多个参数** 时，为每个参数指定一个名称，以便在 XML 映射文件中通过 `#{}` 表达式引用这些参数。

  因为MyBatis 默认会将这些参数封装成一个 Map，但如果你希望显式地为每个参数命名，就可以使用 `@Param` 注解。

```java
public interface UserMapper {
    List<User> selectUsers(@Param("username") String username, @Param("age") int age);
}

<select id="selectUsers" resultType="User">
    SELECT * FROM user
    WHERE username LIKE CONCAT('%', #{username}, '%')
      AND age = #{age}
</select>
```



# LocalDateTime问题

## 有@RequestBody注解

- **有@RequestBody 注解**指定的**参数类**中有LocalDateTime定义的属性，

  >  - 前端请求时需要将**时间**转换为**Long 格式**。
  >
  >  - `参数类型`：**@RequestBody GroupSaveReqVO createReqVO**
  
  ```java
  // 当用@RequestBody注解【限定】请求参数时  前端【请求的时间格式】必须为long类型。
  // GroupSaveReqVO类定义 LocalDateTime tdatetime;
  public CommonResult<Long> createGroup(@Valid @RequestBody GroupSaveReqVO createReqVO) {
  }
  
  public class GroupSaveReqVO {
       private LocalDateTime tdatetime;
  }
  ```
  
  ![image-20250812171606578](assets/image-20250812171606578.png)
  
  
## 无@RequestBody 注解

- `没有`**@RequestBody 注解**指定的**参数类**中有LocalDateTime定义的属性，前端请求时需要将**时间**转换为**yyyy-MM-dd HH:mm:ss**。

  > - `参数类型`： **GroupSaveReqVO createReqVO**, **没有**@RequestBody 注解。
  > - 前端请求时需要将**时间**转换为**yyyy-MM-dd HH:mm:ss**。
  > - LocalDateTime 类型字段需要添加**格式化注解**： @DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)

  ```java
  //前端请求时需要将[时间转换为]yyyy-MM-dd HH:mm:ss格式。
  //LocalDateTime 类型字段添加格式化注解:@DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)
  public CommonResult<PageResult<GroupRespVO>> getGroupPage(@Valid GroupPageReqVO pageReqVO) {
  }
  
  //增加格式化注解@DateTimeFormat
  GroupPageReqVO{
      @DateTimeFormat(pattern = FORMAT_YEAR_MONTH_DAY_HOUR_MINUTE_SECOND)
      private LocalDateTime createTime;
  }
  ```

  ![image-20250812170950030](assets/image-20250812170950030.png)



## LocalDateTime返回

- Response Body 的LocalDateTime定义属性，返回时会**被序列化为 Long 时间戳进行相应**。

![image-20250812145655315](assets/image-20250812145655315.png)



# 代码

```java
//后端登录
cn.iocoder.yudao.module.system.controller.admin.auth.AuthController
```

